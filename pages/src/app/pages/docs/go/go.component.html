<div class="py-12">
  <div class="max-w-4xl mx-auto px-6">
    <nav class="flex items-center gap-2 text-sm text-text-muted mb-8">
      <a routerLink="/docs" class="text-text-secondary hover:text-accent-primary">Docs</a>
      <span>/</span>
      <span>Go</span>
    </nav>

    <article class="prose">
      <span class="inline-block px-2 py-1 bg-cyan-400/15 text-cyan-400 rounded-full text-xs font-medium mb-4">Go</span>
      <h1 class="text-4xl font-bold mb-4">Go Documentation</h1>
      <p class="text-lg text-text-secondary mb-12">
        Idiomatic Go bindings for NanoPDF with CGo integration and standard Go error handling.
      </p>

      <section class="mb-12">
        <h2 class="text-2xl font-semibold mb-6 pb-2 border-b border-bg-tertiary">Installation</h2>
        <pre class="mb-4"><code>go get github.com/lexmata/nanopdf/go-nanopdf</code></pre>
        <p class="text-text-secondary mb-4">Requirements:</p>
        <ul class="list-disc pl-6 text-text-secondary">
          <li class="py-1">Go 1.22 or later</li>
          <li class="py-1">CGo enabled (default)</li>
          <li class="py-1">C compiler (gcc, clang)</li>
        </ul>
      </section>

      <section class="mb-12">
        <h2 class="text-2xl font-semibold mb-6 pb-2 border-b border-bg-tertiary">Basic Usage</h2>
        <pre><code><span class="keyword">package</span> main

<span class="keyword">import</span> (
    <span class="string">"fmt"</span>
    <span class="string">"log"</span>
    
    nanopdf <span class="string">"github.com/lexmata/nanopdf/go-nanopdf"</span>
)

<span class="keyword">func</span> main() &#123;
    <span class="comment">// Open document</span>
    doc, err := nanopdf.OpenDocument(<span class="string">"document.pdf"</span>)
    <span class="keyword">if</span> err != <span class="keyword">nil</span> &#123;
        log.Fatal(err)
    &#125;
    <span class="keyword">defer</span> doc.Close()

    <span class="comment">// Document info</span>
    fmt.Printf(<span class="string">"Pages: %d\n"</span>, doc.PageCount())
    fmt.Printf(<span class="string">"Title: %s\n"</span>, doc.Title())

    <span class="comment">// Load and render page</span>
    page, err := doc.LoadPage(<span class="number">0</span>)
    <span class="keyword">if</span> err != <span class="keyword">nil</span> &#123;
        log.Fatal(err)
    &#125;

    pixmap, err := page.Render(<span class="number">2.0</span>)
    <span class="keyword">if</span> err != <span class="keyword">nil</span> &#123;
        log.Fatal(err)
    &#125;

    <span class="comment">// Save as PNG</span>
    err = pixmap.SavePNG(<span class="string">"page-0.png"</span>)
    <span class="keyword">if</span> err != <span class="keyword">nil</span> &#123;
        log.Fatal(err)
    &#125;
&#125;</code></pre>
      </section>

      <section class="mb-12">
        <h2 class="text-2xl font-semibold mb-6 pb-2 border-b border-bg-tertiary">Thread Safety</h2>
        <p class="text-text-secondary mb-4">NanoPDF Go bindings are thread-safe. You can safely use documents across goroutines:</p>
        <pre><code><span class="keyword">import</span> <span class="string">"sync"</span>

doc, _ := nanopdf.OpenDocument(<span class="string">"large.pdf"</span>)
<span class="keyword">defer</span> doc.Close()

<span class="keyword">var</span> wg sync.WaitGroup
<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; doc.PageCount(); i++ &#123;
    wg.Add(<span class="number">1</span>)
    <span class="keyword">go</span> <span class="keyword">func</span>(pageNum <span class="keyword">int</span>) &#123;
        <span class="keyword">defer</span> wg.Done()
        page, _ := doc.LoadPage(pageNum)
        pixmap, _ := page.Render(<span class="number">2.0</span>)
        pixmap.SavePNG(fmt.Sprintf(<span class="string">"page-%d.png"</span>, pageNum))
    &#125;(i)
&#125;
wg.Wait()</code></pre>
      </section>
    </article>
  </div>
</div>

