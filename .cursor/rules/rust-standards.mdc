---
alwaysApply: false
---
# Rust 2024 Code Generation Standards

This project uses Rust Edition 2024 with modern, safe coding practices.

## Edition and Toolchain

- **Edition**: `2024` (specified in `Cargo.toml`)
- **Minimum Rust Version**: `1.85` or later
- **Target**: Stable Rust (no nightly-only features)

## Safety Requirements

### Unsafe Rust Policy

**NEVER use `unsafe` Rust unless absolutely necessary.** Valid exceptions include:

1. **FFI boundaries** - When exposing functions to C via `extern "C"`
2. **Raw pointer operations** required for C interop
3. **Performance-critical hot paths** where safe alternatives have proven unacceptable overhead (must be benchmarked and documented)

When `unsafe` is required:

```rust
// ✅ CORRECT: Use #[unsafe(no_mangle)] for FFI (Rust 2024 syntax)
#[unsafe(no_mangle)]
pub extern "C" fn fz_new_context() -> u64 {
    // Implementation
}

// ❌ WRONG: Don't use the old syntax
#[no_mangle]  // This is deprecated in Rust 2024
pub extern "C" fn fz_new_context() -> u64 {
    // Implementation
}
```

### Safe Abstractions

Always wrap unsafe operations in safe abstractions:

```rust
// ✅ CORRECT: Handle-based resource management
pub struct HandleStore<T> {
    handles: Mutex<HashMap<u64, Arc<Mutex<T>>>>,
    next_id: AtomicU64,
}

impl<T> HandleStore<T> {
    pub fn insert(&self, value: T) -> u64 {
        // Safe handle creation
    }

    pub fn get(&self, handle: u64) -> Option<Arc<Mutex<T>>> {
        // Safe handle lookup
    }
}
```

## Rust 2024 Specific Syntax

### Reserved Keywords

The following are reserved keywords in Rust 2024 - avoid using them as identifiers:

- `gen` - Use `_gen` or `generation` instead
- `try` - Already reserved

```rust
// ✅ CORRECT
pub fn pdf_new_indirect(num: i32, _gen: i32) -> u64 { }

// ❌ WRONG
pub fn pdf_new_indirect(num: i32, gen: i32) -> u64 { }  // 'gen' is reserved
```

### Attribute Syntax

Use the new attribute syntax for unsafe attributes:

```rust
// ✅ CORRECT (Rust 2024)
#[unsafe(no_mangle)]
#[unsafe(link_section = ".text")]

// ❌ WRONG (pre-2024)
#[no_mangle]
#[link_section = ".text"]
```

## Error Handling

### Use `Result<T, E>` and `thiserror`

Replace C-style error handling with Rust's `Result` type:

```rust
use thiserror::Error;

#[derive(Error, Debug)]
pub enum Error {
    #[error("generic error: {0}")]
    Generic(String),

    #[error("I/O error")]
    System(#[from] std::io::Error),

    #[error("format error: {0}")]
    Format(String),

    #[error("unexpected end of file")]
    Eof,

    #[error("invalid argument: {0}")]
    Argument(String),
}

pub type Result<T> = std::result::Result<T, Error>;
```

### Error Propagation

Use the `?` operator for error propagation:

```rust
// ✅ CORRECT
pub fn read_file(path: &str) -> Result<Buffer> {
    let file = File::open(path)?;
    let mut reader = BufReader::new(file);
    let mut data = Vec::new();
    reader.read_to_end(&mut data)?;
    Ok(Buffer::from_data(data))
}

// ❌ WRONG: Don't use unwrap() in library code
pub fn read_file(path: &str) -> Buffer {
    let file = File::open(path).unwrap();  // Don't do this!
    // ...
}
```

## Memory Management

### Ownership and Borrowing

Prefer ownership over references when appropriate:

```rust
// ✅ CORRECT: Clear ownership semantics
pub fn from_data(data: Vec<u8>) -> Self {
    Self { data: Bytes::from(data) }
}

// ✅ CORRECT: Use references for non-owning access
pub fn as_slice(&self) -> &[u8] {
    &self.data
}
```

### Smart Pointers

Use appropriate smart pointers:

- `Arc<T>` - For shared ownership across threads
- `Mutex<T>` - For interior mutability with thread safety
- `Arc<Mutex<T>>` - For shared mutable state (common in FFI handles)

```rust
// ✅ CORRECT: Thread-safe handle storage
pub static CONTEXTS: LazyLock<HandleStore<Context>> = LazyLock::new(HandleStore::new);

// HandleStore uses Arc<Mutex<T>> for safe concurrent access
```

## Const and Static

### Const Functions

Use `const fn` where possible:

```rust
// ✅ CORRECT
impl<T> HandleStore<T> {
    pub const fn new() -> Self {
        Self {
            handles: Mutex::new(HashMap::new()),
            next_id: AtomicU64::new(1),
        }
    }
}
```

### Static Initialization

Use `LazyLock` for lazy static initialization:

```rust
use std::sync::LazyLock;

// ✅ CORRECT (Rust 2024)
pub static BUFFERS: LazyLock<HandleStore<Buffer>> = LazyLock::new(HandleStore::new);

// ❌ WRONG: Don't use lazy_static! crate
lazy_static! {
    static ref BUFFERS: HandleStore<Buffer> = HandleStore::new();
}
```

## Crate Dependencies

**ALWAYS prefer mature ecosystem crates over custom implementations.**

### Preferred Crates

| Purpose | Crate | Version | Notes |
|---------|-------|---------|-------|
| Error handling | `thiserror` | `2` | Standard for error types |
| Byte manipulation | `bytes`, `byteorder` | `1` | Tokio ecosystem |
| Compression | `flate2` | `1` | Deflate/zlib/gzip |
| LZW compression | `weezl` | `0.1` | Better than custom LZW |
| Encryption | `aes`, `cbc` | `0.8`, `0.1` | RustCrypto standard |
| Hashing | `md-5`, `sha2` | `0.10` | RustCrypto standard |
| Base64 | `base64` | `0.22` | Well-maintained |
| Image processing | `image` | `0.25` | THE Rust image crate |
| Fonts | `fontdb`, `ttf-parser` | Latest | Zero-allocation |
| Parallelism | `rayon` (optional) | `1.10` | Data parallelism |
| Async I/O | `tokio` (optional) | `1` | THE async runtime |
| Futures | `futures` (optional) | `0.3` | Standard utilities |

### Avoid Custom Implementations Of

1. **Compression algorithms** - Use `flate2`, `weezl` instead
2. **Hash functions** - Use RustCrypto crates (`md-5`, `sha2`)
3. **Encryption** - Use RustCrypto crates (`aes`, `cbc`)
4. **Base64/Hex encoding** - Use `base64`, `hex` crates
5. **Byte manipulation** - Use `bytes`, `byteorder` crates
6. **Image formats** - Use `image` crate
7. **Font parsing** - Use `ttf-parser`, `fontdb`

## Code Organization and Module Structure

### File Size Limits

**ALWAYS split large source files into smaller, focused modules.**

Recommended maximum file sizes:

- **Soft limit**: 500 lines per file
- **Hard limit**: 1000 lines per file
- **Action required**: Files >1000 lines MUST be split into submodules

```rust
// ❌ BAD: Single large file (2000+ lines)
// src/ffi/pdf_object.rs - Contains all PDF object operations

// ✅ GOOD: Split into focused modules
// src/ffi/pdf_object/
//   ├── mod.rs          - Re-exports and module structure
//   ├── types.rs        - Core types and data structures
//   ├── create.rs       - Object creation functions
//   ├── lifecycle.rs    - Keep/drop/refcount operations
//   ├── array.rs        - Array operations
//   ├── dict.rs         - Dictionary operations
//   └── conversion.rs   - Type conversions
```

### When to Split a File

Split a file into submodules when:

1. **File exceeds 1000 lines**
2. **Multiple distinct responsibilities** (violates Single Responsibility Principle)
3. **Clear logical groupings** exist (create, read, update, delete)
4. **Different feature sets** that could be conditionally compiled
5. **Hard to navigate** or find specific functionality

### Module Organization Patterns

#### Pattern 1: By Functionality

```rust
// src/pdf/filter/
mod mod.rs;          // Public API and FilterType enum
mod flate.rs;        // FlateDecode implementation
mod lzw.rs;          // LZWDecode implementation
mod ascii85.rs;      // ASCII85Decode implementation
mod asciihex.rs;     // ASCIIHexDecode implementation
mod predictor.rs;    // Shared predictor functions
mod chain.rs;        // Filter chaining logic

// In mod.rs - re-export everything
pub use flate::*;
pub use lzw::*;
pub use ascii85::*;
```

#### Pattern 2: By Object Lifecycle

```rust
// src/ffi/buffer/
mod core.rs;         // Core Buffer struct and methods
mod lifecycle.rs;    // new, keep, drop functions
mod data_ops.rs;     // append, clear, resize operations
mod conversion.rs;   // to_bytes, from_slice, etc.
mod io.rs;          // Read/Write trait implementations
```

#### Pattern 3: By Layer (Recommended for FFI)

```rust
// src/ffi/pixmap/
mod core.rs;         // Internal Pixmap structure
mod lifecycle.rs;    // FFI lifecycle functions
mod properties.rs;   // FFI property getters
mod operations.rs;   // FFI operations (clear, invert, etc.)
mod pixel_access.rs; // FFI pixel-level access
```

### Module File Structure

#### Main Module File (mod.rs)

```rust
//! Module-level documentation
//!
//! Describes the overall purpose of this module.

// Submodule declarations
mod core;
mod operations;
mod helpers;

// Re-exports (keep public API clean)
pub use core::{MainType, ImportantTrait};
pub use operations::*;

// Internal items stay private
use helpers::internal_function;

// Module-level tests (if small)
#[cfg(test)]
mod tests {
    use super::*;
    // ...
}
```

#### Individual Module Files

```rust
//! Focused documentation for this specific module

use super::core::MainType;
use crate::other::SomeType;

// Keep tests WITH the implementation
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_specific_function() {
        // Test code here
    }
}
```

### Module Splitting Guidelines

#### Step 1: Identify Logical Groups

Look for:
- Groups of related functions (all array operations, all dict operations)
- Different phases (creation, modification, destruction)
- Feature boundaries (optional features, platform-specific)
- Type families (different kinds of objects)

#### Step 2: Create Module Structure

```bash
# Before: Single large file
src/ffi/buffer.rs (1189 lines)

# After: Organized modules
src/ffi/buffer/
├── mod.rs          # 50 lines  - Public API
├── core.rs         # 200 lines - Core types
├── lifecycle.rs    # 150 lines - Creation/destruction
├── data_ops.rs     # 300 lines - Data operations
├── conversion.rs   # 250 lines - Conversions
└── encoding.rs     # 239 lines - Encoding operations
```

#### Step 3: Move Code Systematically

1. Create the submodule directory
2. Create `mod.rs` with module declarations
3. Move related code to focused files
4. Keep tests WITH their implementations
5. Update imports and re-exports
6. Verify with `cargo build` and `cargo test`

### Re-exports Best Practices

Keep your public API clean:

```rust
// ✅ GOOD: Clean re-exports in mod.rs
mod types;
mod create;
mod operations;

// Re-export public API
pub use types::{PdfObj, PdfObjType};
pub use create::*;
pub use operations::*;

// Users can simply: use crate::pdf_object::{PdfObj, create_null};
```

```rust
// ❌ BAD: Forcing users to know internal structure
mod types;
mod create;
mod operations;

// Users have to: use crate::pdf_object::types::PdfObj;
// Users have to: use crate::pdf_object::create::create_null;
```

### Anti-Patterns to Avoid

#### ❌ Don't Split Just to Split

```rust
// ❌ BAD: Unnecessary splits
mod add.rs          // Just one function
mod subtract.rs     // Just one function
mod multiply.rs     // Just one function

// ✅ GOOD: Keep related operations together
mod arithmetic.rs   // All basic arithmetic
```

#### ❌ Don't Create Circular Dependencies

```rust
// ❌ BAD: Module A depends on B, B depends on A
// src/module_a.rs
use crate::module_b::TypeB;

// src/module_b.rs
use crate::module_a::TypeA;  // Circular!

// ✅ GOOD: Extract common types to a separate module
// src/types.rs
pub struct TypeA;
pub struct TypeB;

// src/module_a.rs
use crate::types::{TypeA, TypeB};

// src/module_b.rs
use crate::types::{TypeA, TypeB};
```

#### ❌ Don't Duplicate Code Across Modules

```rust
// ❌ BAD: Duplicated helper function in each module
// src/module_a.rs
fn helper() { /* ... */ }

// src/module_b.rs
fn helper() { /* ... */ }  // Same function!

// ✅ GOOD: Shared helpers in a common module
// src/common/helpers.rs
pub(crate) fn helper() { /* ... */ }

// src/module_a.rs
use crate::common::helpers::helper;

// src/module_b.rs
use crate::common::helpers::helper;
```

### Module Organization Checklist

When organizing modules:

- [ ] Each file has a single, clear responsibility
- [ ] File is under 1000 lines (preferably under 500)
- [ ] Tests are in the same file as implementation
- [ ] Related functionality is grouped together
- [ ] Public API is clean and well-documented
- [ ] No circular dependencies
- [ ] Common code is shared, not duplicated
- [ ] Module structure mirrors conceptual organization

### Example: Before and After

#### Before (2000+ lines in one file)

```rust
// src/ffi/pdf_object.rs (2077 lines - too large!)

pub struct PdfObj { /* ... */ }
pub extern "C" fn pdf_new_null() { /* ... */ }
pub extern "C" fn pdf_new_bool() { /* ... */ }
pub extern "C" fn pdf_keep_obj() { /* ... */ }
pub extern "C" fn pdf_drop_obj() { /* ... */ }
pub extern "C" fn pdf_array_len() { /* ... */ }
pub extern "C" fn pdf_array_push() { /* ... */ }
// ... 50+ more functions ...
```

#### After (modularized)

```rust
// src/ffi/pdf_object/mod.rs (40 lines)
mod types;
mod create;
mod refcount;
mod array;
mod dict;

pub use types::*;
pub use create::*;
pub use refcount::*;
pub use array::*;
pub use dict::*;

// src/ffi/pdf_object/types.rs (200 lines)
pub struct PdfObj { /* ... */ }
pub enum PdfObjType { /* ... */ }

// src/ffi/pdf_object/create.rs (150 lines)
pub extern "C" fn pdf_new_null() { /* ... */ }
pub extern "C" fn pdf_new_bool() { /* ... */ }

// src/ffi/pdf_object/refcount.rs (100 lines)
pub extern "C" fn pdf_keep_obj() { /* ... */ }
pub extern "C" fn pdf_drop_obj() { /* ... */ }

// src/ffi/pdf_object/array.rs (200 lines)
pub extern "C" fn pdf_array_len() { /* ... */ }
pub extern "C" fn pdf_array_push() { /* ... */ }
```

**Result**: Much easier to navigate, understand, and maintain!

## Testing

### Unit Tests

Include unit tests in the same file:

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_buffer_new() {
        let b = Buffer::new(100);
        assert_eq!(b.len(), 0);
        assert!(b.is_empty());
    }
}
```

### Test Coverage

Aim for 90% test coverage. Use `cargo tarpaulin` to measure:

```bash
cargo tarpaulin --out Html
```

## Documentation

### Doc Comments

Use `///` for public API documentation:

```rust
/// Creates a new buffer with the specified capacity.
///
/// # Arguments
///
/// * `capacity` - The initial capacity in bytes
///
/// # Returns
///
/// A new empty buffer with the given capacity.
///
/// # Examples
///
/// ```
/// let buffer = Buffer::new(1024);
/// assert!(buffer.is_empty());
/// ```
pub fn new(capacity: usize) -> Self {
    // ...
}
```

### Module Documentation

Use `//!` for module-level documentation:

```rust
//! Buffer - Dynamic byte array wrapper using the `bytes` crate
//!
//! This module provides a high-performance buffer implementation backed by
//! `bytes::Bytes` and `bytes::BytesMut` for efficient zero-copy operations.
```

## Formatting and Linting

### Rustfmt

Use default `rustfmt` settings. Run before committing:

```bash
cargo fmt
```

### Clippy

Run Clippy and fix all warnings:

```bash
cargo clippy -- -D warnings
```

## Feature Flags

Use feature flags for optional functionality:

```toml
[features]
default = []
jpeg2000 = ["jpeg2k"]
jbig2 = []
parallel = ["rayon"]
async = ["tokio", "futures"]
```

```rust
#[cfg(feature = "parallel")]
pub mod parallel {
    use rayon::prelude::*;
    // ...
}
```

## Summary Checklist

- [ ] Edition 2024 syntax (`#[unsafe(no_mangle)]`)
- [ ] No `unsafe` except at FFI boundaries
- [ ] `Result<T, E>` for error handling
- [ ] `thiserror` for error types
- [ ] `LazyLock` for static initialization
- [ ] `Arc<Mutex<T>>` for shared mutable state
- [ ] Comprehensive unit tests (90% coverage target)
- [ ] Doc comments on public API
- [ ] `cargo fmt` and `cargo clippy` clean
